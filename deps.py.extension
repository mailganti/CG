# new imports at top of deps.py:
import os
import jwt
from datetime import datetime, timezone
from controller.emailer import send_email
from controller.db.db import get_db

# JWT settings for approvers
APPROVER_JWT_SECRET = os.getenv("APPROVER_JWT_SECRET", "change-me")
APPROVER_JWT_ALGO = os.getenv("APPROVER_JWT_ALGO", "HS256")

def verify_approver_jwt(auth_header: str = Header(None)):
    """
    Verify approver JWT passed as Authorization: Bearer <token>
    Returns payload if valid and role is approver/admin
    """
    if not auth_header:
        raise HTTPException(status_code=401, detail="Missing Authorization header")
    if not auth_header.lower().startswith("bearer "):
        raise HTTPException(status_code=401, detail="Invalid Authorization header")
    token = auth_header.split(" ",1)[1].strip()
    try:
        payload = jwt.decode(token, APPROVER_JWT_SECRET, algorithms=[APPROVER_JWT_ALGO])
        role = payload.get("role")
        if role not in ("approver", "admin"):
            raise HTTPException(status_code=403, detail="Approver role required")
        return payload
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="Approver token expired")
    except Exception as e:
        raise HTTPException(status_code=401, detail=f"Invalid approver token: {e}")

def require_execution_token(workflow_id: str):
    """
    Dependency factory that returns a dependency to validate X-Execution-Token header for a given workflow_id
    Usage:
        @app.post("/workflows/{id}/execute")
        async def exec(..., token_valid = Depends(require_execution_token(workflow_id))):
            ...
    """
    from fastapi import Header

    def _dep(x_execution_token: Optional[str] = Header(None), user: dict = Depends(verify_token)):
        db = get_db()
        if not x_execution_token:
            raise HTTPException(status_code=403, detail="Execution token required")

        token_row = db.get_execution_token_by_value(x_execution_token)
        if not token_row:
            raise HTTPException(status_code=403, detail="Invalid execution token")

        if token_row['workflow_id'] != workflow_id:
            raise HTTPException(status_code=403, detail="Token not valid for this workflow")

        if token_row['used']:
            raise HTTPException(status_code=403, detail="Token has already been used")

        expires_at = token_row.get('expires_at')
        if expires_at:
            try:
                exp_dt = datetime.fromisoformat(expires_at)
                if exp_dt < datetime.now():
                    raise HTTPException(status_code=403, detail="Execution token expired")
            except Exception:
                # ignore parse errors
                pass

        # mark token used by this user (one-time)
        ok = db.mark_execution_token_used(token_row['id'], user.get('username', user.get('token_name', 'unknown')))
        if not ok:
            raise HTTPException(status_code=403, detail="Failed to mark token used or token already used")

        return token_row

    return _dep
