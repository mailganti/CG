"""
async_ssl_proxy.py

Async dual-auth SSL reverse proxy:
 - Prefer client TLS certificate (smart card)
 - Optional Windows Native Auth (SPNEGO) fallback
 - Forwards requests to backend (HTTP) and injects identity headers:
     X-Auth-User, X-Auth-Method, X-Client-DN
 - Removes domain prefix (e.g. "U\\") from usernames before forwarding
 - Robust error handling to avoid 502 'remote closed connection' cases
"""

import asyncio
import base64
import logging
import socket
import ssl
from typing import Optional, Tuple, Dict

from aiohttp import web, ClientTimeout, ClientSession, ClientConnectionError, TCPConnector
from cryptography import x509
from cryptography.hazmat.backends import default_backend

# Optional SPNEGO
try:
    import spnego
    SPNEGO_AVAILABLE = True
except Exception:
    SPNEGO_AVAILABLE = False

# ===========================
# CONFIGURATION
# ===========================
PROXY_HOST = "0.0.0.0"
PROXY_PORT = 7605

BACKEND_SCHEME = "http"
BACKEND_HOST = "127.0.0.1"
BACKEND_PORT = 8000
BACKEND_BASE = f"{BACKEND_SCHEME}://{BACKEND_HOST}:{BACKEND_PORT}"

# TLS files for proxy server
SERVER_CERT_FILE = "controller/certs/cert.pem"
SERVER_KEY_FILE = "controller/certs/key.pem"
CA_CERT_FILE = "controller/certs/certChain.pem"

# Client cert verification (ssl.CERT_NONE / ssl.CERT_OPTIONAL / ssl.CERT_REQUIRED)
CLIENT_CERT_REQUIRED = ssl.CERT_OPTIONAL

# WNA fallback
ENABLE_WNA_FALLBACK = True
WNA_SERVICE_NAME = "HTTP"

# Headers injected to backend
AUTH_USER_HEADER = "X-Auth-User"
AUTH_METHOD_HEADER = "X-Auth-Method"
CERT_DN_HEADER = "X-Client-DN"
FORWARDED_FOR_HEADER = "X-Forwarded-For"
FORWARDED_PROTO_HEADER = "X-Forwarded-Proto"

# Trusted proxies (if you accept proxies setting X-Forwarded-For etc)
TRUSTED_PROXIES = ["127.0.0.1", "::1"]

# Timeout for backend requests
BACKEND_TIMEOUT_SECONDS = 60

# Logging
LOG_LEVEL = logging.INFO
LOG_FORMAT = "%(asctime)s - %(name)s - %(levelname)s - %(message)s"

logging.basicConfig(level=LOG_LEVEL, format=LOG_FORMAT)
logger = logging.getLogger("async_ssl_proxy")

# ===========================
# Helper: Certificate parsing
# ===========================
def extract_cert_identity_from_der(cert_der: bytes) -> Tuple[Optional[str], Optional[str], Optional[str]]:
    """
    Given DER-encoded certificate bytes, return (username, domain, cert_dn).
    username: Common Name (CN) if present
    domain: Organization short name (first token before dot) if present
    cert_dn: Printable DN string
    """
    if not cert_der:
        return None, None, None
    try:
        cert = x509.load_der_x509_certificate(cert_der, default_backend())
        subject = cert.subject

        # CN
        cn_attr = subject.get_attributes_for_oid(x509.oid.NameOID.COMMON_NAME)
        cn = cn_attr[0].value if cn_attr else None

        # Organization -> derive short domain
        org_attr = subject.get_attributes_for_oid(x509.oid.NameOID.ORGANIZATION_NAME)
        domain = None
        if org_attr:
            org = org_attr[0].value
            if org:
                domain = org.split(".")[0].upper()

        # Build DN
        dn_parts = []
        for rdn in subject.rdns:
            for attr in rdn:
                # Use attribute name if available, else OID
                name = getattr(attr.oid, "_name", None) or attr.oid.dotted_string
                dn_parts.append(f"{name}={attr.value}")
        cert_dn = ", ".join(dn_parts) if dn_parts else None

        username = cn or None
        return username, domain, cert_dn
    except Exception as e:
        logger.exception("Failed to parse client certificate: %s", e)
        return None, None, None

# ===========================
# Helper: Parse and sanitize Windows identity strings
# ===========================
def parse_wna_identity(identity: str) -> Tuple[Optional[str], Optional[str]]:
    """
    Parse identity strings like:
      - DOMAIN\\user
      - user@domain.com
      - user
    Returns (username, domain) where domain may be None.
    Also strips common leading domain shortnames like 'U\\' if present.
    """
    if not identity:
        return None, None

    # Some libraries return principal like "DOMAIN\\user" or "user@REALM"
    # Ensure we handle domain prefix stripping robustly.
    if "\\" in identity:
        parts = identity.split("\\", 1)
        domain = parts[0].strip()
        user = parts[1].strip()
        # If domain is a single-letter like "U" coming from some Windows logins,
        # treat it as domain and still return username without prefix.
        return user, domain.upper() if domain else None

    if "@" in identity:
        u, realm = identity.split("@", 1)
        domain = realm.split(".")[0].upper() if realm else None
        return u, domain

    # Fallback - no domain
    return identity, None

# ===========================
# SPNEGO manager (thread-safe)
# ===========================
class SPNEGOAuthManager:
    """
    Lightweight per-connection SPNEGO context manager.
    SPNEGO operations are performed synchronously by the pyspnego library,
    so they are executed in a thread executor to avoid blocking the event loop.
    """
    def __init__(self):
        self._contexts = {}
        self._lock = asyncio.Lock()

    async def get_or_create(self, conn_id: str):
        if not SPNEGO_AVAILABLE:
            return None
        async with self._lock:
            if conn_id not in self._contexts:
                try:
                    # create server context (pyspnego)
                    self._contexts[conn_id] = spnego.server(service=WNA_SERVICE_NAME, hostname=socket.gethostname())
                except Exception:
                    logger.exception("SPNEGO context creation failed")
                    return None
            return self._contexts[conn_id]

    async def remove(self, conn_id: str):
        async with self._lock:
            self._contexts.pop(conn_id, None)

    async def step(self, conn_id: str, in_token: Optional[bytes]):
        """
        Process a SPNEGO step. Returns tuple (complete: bool, username: Optional[str], out_token: Optional[bytes])
        """
        if not SPNEGO_AVAILABLE:
            return False, None, None

        ctx = await self.get_or_create(conn_id)
        if not ctx:
            return False, None, None

        loop = asyncio.get_running_loop()
        try:
            # Run blocking ctx.step in thread pool
            out_token = await loop.run_in_executor(None, ctx.step, in_token)
            if getattr(ctx, "complete", False):
                username = str(getattr(ctx, "client_principal", None)) if getattr(ctx, "client_principal", None) else None
                # cleanup
                await self.remove(conn_id)
                return True, username, out_token
            else:
                return False, None, out_token
        except Exception:
            logger.exception("SPNEGO step failed")
            await self.remove(conn_id)
            return False, None, None

spnego_manager = SPNEGOAuthManager()

# ===========================
# Proxy handler (aiohttp)
# ===========================
class DualAuthProxy:
    def __init__(self):
        timeout = ClientTimeout(total=BACKEND_TIMEOUT_SECONDS)
        # Keep-alive connector to backend
        self._client = ClientSession(connector=TCPConnector(limit=100), timeout=timeout)

    async def close(self):
        await self._client.close()

    async def get_peer_cert_der(self, request: web.Request) -> Optional[bytes]:
        """
        Attempt to get the peer certificate in DER form from the request transport.
        Note: availability depends on SSLContext configuration and underlying server.
        """
        try:
            transport = request.transport
            if not transport:
                return None

            # Try getpeercert via ssl_object
            sslobj = transport.get_extra_info("ssl_object")
            if sslobj:
                # binary_form=True yields DER bytes
                der = sslobj.getpeercert(binary_form=True)
                return der

            # Fallback: some servers may expose 'peercert' directly
            peercert = transport.get_extra_info("peercert")
            if peercert:
                # If peercert is a dict, we cannot reconstruct DER easily
                return None
        except Exception:
            logger.exception("Could not retrieve peer cert from transport")
        return None

    async def handle_request(self, request: web.Request) -> web.Response:
        """
        Main request handler:
         - Extract client cert (if any)
         - Optionally perform SPNEGO if no cert (and fallback enabled)
         - Forward request to backend with proper headers
        """
        client_ip = request.remote
        path_qs = request.raw_path  # includes path + query
        method = request.method
        headers = dict(request.headers)

        # 1) Try client certificate auth
        cert_der = await self.get_peer_cert_der(request)
        auth_user = None
        auth_method = None
        cert_dn = None

        if cert_der:
            username, domain, cert_dn = extract_cert_identity_from_der(cert_der)
            if username:
                # Strip domain addition from username in final forwarded header
                if domain:
                    auth_user = f"{domain}\\{username}"
                else:
                    auth_user = username
                auth_method = "smartcard"
                logger.info("[%s] Smart Card auth: %s", client_ip, auth_user)
        else:
            # 2) WNA fallback (SPNEGO)
            if ENABLE_WNA_FALLBACK and SPNEGO_AVAILABLE:
                auth_hdr = headers.get("Authorization", "")
                if auth_hdr and auth_hdr.lower().startswith("negotiate"):
                    # extract token and process via spnego_manager
                    token_b64 = auth_hdr.split(" ", 1)[1] if " " in auth_hdr else ""
                    in_token = base64.b64decode(token_b64) if token_b64 else None
                    # Use remote peer+port as connection id to keep per-connection context
                    conn_id = f"{client_ip}:{request.transport.get_extra_info('peername')[1] if request.transport.get_extra_info('peername') else '0'}"
                    complete, username, out_token = await spnego_manager.step(conn_id, in_token)
                    if not complete and out_token:
                        # need additional round - respond with 401 challenge
                        out_b64 = base64.b64encode(out_token).decode()
                        return web.Response(status=401, headers={"WWW-Authenticate": f"Negotiate {out_b64}"}, body=b"")
                    if complete and username:
                        user, domain = parse_wna_identity(username)
                        auth_user = f"{domain}\\{user}" if domain else user
                        auth_method = "wna"
                        logger.info("[%s] WNA auth: %s", client_ip, auth_user)
                else:
                    # No Authorization header - initial Negotiate challenge
                    # We want the client (browser) to respond with SPNEGO tokens
                    return web.Response(status=401, headers={"WWW-Authenticate": "Negotiate"}, text="401 Authentication Required")
            else:
                # No authentication available
                logger.warning("[%s] No auth provided; rejecting", client_ip)
                return web.Response(status=401, text="Authentication required")

        # Sanitize username before forwarding (remove stray domain prefix like single-letter 'U\')
        if auth_user:
            # Normalize: if format DOMAIN\username, keep it; else ensure no leading backslash
            if "\\" in auth_user:
                domain_part, user_part = auth_user.split("\\", 1)
                # if domain is suspicious (single-letter) we still preserve domain but forward as-is
                auth_user = f"{domain_part}\\{user_part}"
            else:
                auth_user = auth_user.lstrip("\\").strip()

        # 3) Build headers for backend
        forward_headers = {}
        # Copy incoming headers but remove hop-by-hop and Authorization
        hop_by_hop = {
            "connection", "keep-alive", "proxy-authenticate", "proxy-authorization",
            "te", "trailers", "transfer-encoding", "upgrade", "authorization"
        }
        for k, v in headers.items():
            if k.lower() in hop_by_hop:
                continue
            forward_headers[k] = v

        # Add auth headers
        if auth_user:
            forward_headers[AUTH_USER_HEADER] = auth_user
        if auth_method:
            forward_headers[AUTH_METHOD_HEADER] = auth_method
        if cert_dn:
            forward_headers[CERT_DN_HEADER] = cert_dn

        # Add forwarded headers (append if already present)
        xff = forward_headers.get(FORWARDED_FOR_HEADER)
        if xff:
            forward_headers[FORWARDED_FOR_HEADER] = f"{xff}, {client_ip}"
        else:
            forward_headers[FORWARDED_FOR_HEADER] = client_ip

        forward_headers[FORWARDED_PROTO_HEADER] = "https"

        # 4) Read body safely (streaming-aware)
        body = await request.read()

        # 5) Proxy to backend using aiohttp ClientSession
        target_url = f"{BACKEND_BASE}{path_qs}"
        try:
            async with self._client.request(method, target_url, headers=forward_headers, data=body) as resp:
                # Build response back to client
                resp_body = await resp.read()
                # Filter hop-by-hop response headers
                response_headers = {}
                for k, v in resp.headers.items():
                    if k.lower() in ("transfer-encoding", "connection"):
                        continue
                    response_headers[k] = v
                return web.Response(status=resp.status, body=resp_body, headers=response_headers)
        except ClientConnectionError as e:
            logger.exception("Backend connection failed: %s", e)
            # Return a clean 502 with explanation to avoid proxy dropping connection
            return web.Response(status=502, text=f"Bad Gateway: backend connection failed: {e}")
        except asyncio.TimeoutError:
            logger.exception("Backend request timed out")
            return web.Response(status=504, text="Gateway Timeout: backend did not respond")
        except Exception as e:
            logger.exception("Unexpected proxy error: %s", e)
            return web.Response(status=502, text=f"Bad Gateway: unexpected error: {e}")

# ===========================
# App setup and run
# ===========================
async def init_app() -> web.Application:
    proxy = DualAuthProxy()
    app = web.Application()
    app["proxy"] = proxy

    # single catch-all route
    async def handler(request):
        return await app["proxy"].handle_request(request)

    app.router.add_route("*", "/{path_info:.*}", handler)
    return app

def create_ssl_context() -> ssl.SSLContext:
    ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
    ctx.options |= ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1
    # load server cert
    ctx.load_cert_chain(SERVER_CERT_FILE, SERVER_KEY_FILE)
    # client cert verification if CA provided
    try:
        ctx.load_verify_locations(CA_CERT_FILE)
        ctx.verify_mode = CLIENT_CERT_REQUIRED
        logger.info("Loaded CA for client verification; verify_mode=%s", CLIENT_CERT_REQUIRED)
    except Exception:
        logger.warning("Could not load CA file, client cert verification disabled")
        ctx.verify_mode = ssl.CERT_NONE

    # modern TLS minimum
    try:
        ctx.minimum_version = ssl.TLSVersion.TLSv1_2
    except AttributeError:
        # older Python - ignore
        pass
    return ctx

def main():
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)

    app = loop.run_until_complete(init_app())
    ssl_ctx = create_ssl_context()

    # Run aiohttp web server with SSL
    web.run_app(app, host=PROXY_HOST, port=PROXY_PORT, ssl_context=ssl_ctx)

if __name__ == "__main__":
    main()
