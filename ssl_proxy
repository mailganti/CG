#!/usr/bin/env python3
"""
async_ssl_proxy.py

Async dual-auth SSL reverse proxy:
 - Prefer client TLS certificate (smart card)
 - Optional Windows Native Auth (SPNEGO) fallback
 - Forwards requests to backend (HTTP) and injects identity headers:
     X-Auth-User, X-Auth-Method, X-Client-DN
 - Removes single-letter domain prefix (e.g. "U\\") from usernames by default
 - Streams backend responses (preserves keep-alive, avoids server disconnects)
 - Creates ClientSession inside event loop to avoid timeout-context errors
"""

import asyncio
import base64
import logging
import socket
import ssl
from typing import Optional, Tuple

from aiohttp import web, ClientTimeout, ClientSession, ClientConnectionError, TCPConnector
from cryptography import x509
from cryptography.hazmat.backends import default_backend

# Optional SPNEGO (pyspnego)
try:
    import spnego
    SPNEGO_AVAILABLE = True
except Exception:
    SPNEGO_AVAILABLE = False

# ===========================
# CONFIGURATION - adjust these
# ===========================
PROXY_HOST = "0.0.0.0"
PROXY_PORT = 7605

BACKEND_SCHEME = "http"
BACKEND_HOST = "127.0.0.1"
BACKEND_PORT = 8000
BACKEND_BASE = f"{BACKEND_SCHEME}://{BACKEND_HOST}:{BACKEND_PORT}"

SERVER_CERT_FILE = "controller/certs/cert.pem"
SERVER_KEY_FILE = "controller/certs/key.pem"
CA_CERT_FILE = "controller/certs/certChain.pem"

CLIENT_CERT_REQUIRED = ssl.CERT_OPTIONAL  # or ssl.CERT_REQUIRED

ENABLE_WNA_FALLBACK = True
WNA_SERVICE_NAME = "HTTP"

AUTH_USER_HEADER = "X-Auth-User"
AUTH_METHOD_HEADER = "X-Auth-Method"
CERT_DN_HEADER = "X-Client-DN"
FORWARDED_FOR_HEADER = "X-Forwarded-For"
FORWARDED_PROTO_HEADER = "X-Forwarded-Proto"

TRUSTED_PROXIES = ["127.0.0.1", "::1"]  # optionally enforce if front proxy sets headers

BACKEND_TIMEOUT_SECONDS = 60

LOG_LEVEL = logging.INFO
LOG_FORMAT = "%(asctime)s - %(name)s - %(levelname)s - %(message)s"

logging.basicConfig(level=LOG_LEVEL, format=LOG_FORMAT)
logger = logging.getLogger("async_ssl_proxy")

# ===========================
# Certificate parsing helpers
# ===========================
def extract_cert_identity_from_der(cert_der: bytes) -> Tuple[Optional[str], Optional[str], Optional[str]]:
    """
    Extract username (CN), domain (derived from O/organization), and printable DN from DER-encoded cert.
    Treat single-letter domains as absent (to avoid U\ prefix artifacts).
    """
    if not cert_der:
        return None, None, None
    try:
        cert = x509.load_der_x509_certificate(cert_der, default_backend())
        subject = cert.subject

        cn_attr = subject.get_attributes_for_oid(x509.oid.NameOID.COMMON_NAME)
        cn = cn_attr[0].value if cn_attr else None

        org_attr = subject.get_attributes_for_oid(x509.oid.NameOID.ORGANIZATION_NAME)
        domain = None
        if org_attr:
            org = org_attr[0].value
            if org:
                domain = org.split(".")[0].upper()

        dn_parts = []
        for rdn in subject.rdns:
            for attr in rdn:
                name = getattr(attr.oid, "_name", None) or attr.oid.dotted_string
                dn_parts.append(f"{name}={attr.value}")
        cert_dn = ", ".join(dn_parts) if dn_parts else None

        # Normalize single-letter domain -> treat as absent
        if domain and len(domain) == 1:
            domain = None

        username = cn or None
        return username, domain, cert_dn
    except Exception:
        logger.exception("Failed to parse client certificate")
        return None, None, None

# ===========================
# WNA identity parser
# ===========================
def parse_wna_identity(identity: str) -> Tuple[Optional[str], Optional[str]]:
    """
    Parse identity strings: DOMAIN\\user, user@REALM, or user.
    Single-letter domains are treated as absent to avoid U\ artifacts.
    """
    if not identity:
        return None, None

    if "\\" in identity:
        parts = identity.split("\\", 1)
        domain = parts[0].strip().upper() if parts[0].strip() else None
        user = parts[1].strip()
        if domain and len(domain) == 1:
            domain = None
        return user, domain

    if "@" in identity:
        u, realm = identity.split("@", 1)
        domain = realm.split(".")[0].upper() if realm else None
        if domain and len(domain) == 1:
            domain = None
        return u, domain

    return identity, None

# ===========================
# SPNEGO manager (non-blocking wrapper)
# ===========================
class SPNEGOAuthManager:
    def __init__(self):
        self._contexts = {}
        self._lock = asyncio.Lock()

    async def get_or_create(self, conn_id: str):
        if not SPNEGO_AVAILABLE:
            return None
        async with self._lock:
            if conn_id not in self._contexts:
                try:
                    self._contexts[conn_id] = spnego.server(service=WNA_SERVICE_NAME, hostname=socket.gethostname())
                except Exception:
                    logger.exception("Failed creating SPNEGO context")
                    return None
            return self._contexts[conn_id]

    async def remove(self, conn_id: str):
        async with self._lock:
            self._contexts.pop(conn_id, None)

    async def step(self, conn_id: str, in_token: Optional[bytes]):
        """
        Run ctx.step in threadpool to avoid blocking event loop.
        Returns (complete, username, out_token)
        """
        if not SPNEGO_AVAILABLE:
            return False, None, None

        ctx = await self.get_or_create(conn_id)
        if not ctx:
            return False, None, None

        loop = asyncio.get_running_loop()
        try:
            out_token = await loop.run_in_executor(None, ctx.step, in_token)
            if getattr(ctx, "complete", False):
                username = str(getattr(ctx, "client_principal", None)) if getattr(ctx, "client_principal", None) else None
                await self.remove(conn_id)
                return True, username, out_token
            return False, None, out_token
        except Exception:
            logger.exception("SPNEGO step failed")
            await self.remove(conn_id)
            return False, None, None

spnego_manager = SPNEGOAuthManager()

# ===========================
# Proxy core
# ===========================
class DualAuthProxy:
    def __init__(self):
        # ClientSession will be created on startup hook (inside server loop)
        self._client: Optional[ClientSession] = None

    async def start(self):
        if self._client is None:
            timeout = ClientTimeout(total=BACKEND_TIMEOUT_SECONDS)
            self._client = ClientSession(connector=TCPConnector(limit=100), timeout=timeout)
            logger.info("Backend ClientSession created")

    async def close(self):
        if self._client:
            await self._client.close()
            self._client = None
            logger.info("Backend ClientSession closed")

    async def _get_peer_cert_der(self, request: web.Request) -> Optional[bytes]:
        """
        Try to obtain peer cert DER bytes from transport's ssl_object.
        When TLS termination happens upstream, the frontend must forward cert data via headers.
        """
        try:
            transport = request.transport
            if not transport:
                return None
            sslobj = transport.get_extra_info("ssl_object")
            if sslobj:
                return sslobj.getpeercert(binary_form=True)
            return None
        except Exception:
            logger.exception("Error retrieving peer cert from transport")
            return None

    async def handle_request(self, request: web.Request) -> web.StreamResponse:
        client_ip = request.remote
        path_qs = request.raw_path  # includes query
        method = request.method
        headers = dict(request.headers)

        # 1) Certificate auth
        cert_der = await self._get_peer_cert_der(request)
        auth_user = None
        auth_method = None
        cert_dn = None

        if cert_der:
            user, domain, cert_dn = extract_cert_identity_from_der(cert_der)
            if user:
                auth_user = f"{domain}\\{user}" if domain else user
                auth_method = "smartcard"
                logger.info("[%s] Smart Card auth: %s", client_ip, auth_user)
        else:
            # 2) SPNEGO fallback
            if ENABLE_WNA_FALLBACK and SPNEGO_AVAILABLE:
                auth_hdr = headers.get("Authorization", "")
                if auth_hdr and auth_hdr.lower().startswith("negotiate"):
                    token_b64 = auth_hdr.split(" ", 1)[1] if " " in auth_hdr else ""
                    in_token = base64.b64decode(token_b64) if token_b64 else None
                    peername = request.transport.get_extra_info("peername") or ()
                    peer_port = peername[1] if len(peername) > 1 else 0
                    conn_id = f"{client_ip}:{peer_port}"
                    complete, username, out_token = await spnego_manager.step(conn_id, in_token)
                    if not complete and out_token:
                        out_b64 = base64.b64encode(out_token).decode()
                        # challenge for next round
                        return web.Response(status=401, headers={"WWW-Authenticate": f"Negotiate {out_b64}"}, body=b"")
                    if complete and username:
                        user, domain = parse_wna_identity(username)
                        auth_user = f"{domain}\\{user}" if domain else user
                        auth_method = "wna"
                        logger.info("[%s] WNA auth: %s", client_ip, auth_user)
                else:
                    # initial challenge
                    return web.Response(status=401, headers={"WWW-Authenticate": "Negotiate"}, text="401 Authentication Required")
            else:
                logger.warning("[%s] No authentication supplied - rejecting", client_ip)
                return web.Response(status=401, text="Authentication required")

        # Sanitize user - remove leading backslashes and whitespace
        if auth_user:
            auth_user = auth_user.lstrip("\\").strip()

        # Build headers for backend
        forward_headers = {}
        hop_by_hop = {
            "connection", "keep-alive", "proxy-authenticate", "proxy-authorization",
            "te", "trailers", "transfer-encoding", "upgrade", "authorization"
        }
        for k, v in headers.items():
            if k.lower() in hop_by_hop:
                continue
            # optionally: validate trusted proxies before accepting X-Forwarded-For from earlier hops
            forward_headers[k] = v

        # Inject identity headers
        if auth_user:
            forward_headers[AUTH_USER_HEADER] = auth_user
        if auth_method:
            forward_headers[AUTH_METHOD_HEADER] = auth_method
        if cert_dn:
            forward_headers[CERT_DN_HEADER] = cert_dn

        # X-Forwarded-For and proto
        xff = forward_headers.get(FORWARDED_FOR_HEADER)
        if xff:
            forward_headers[FORWARDED_FOR_HEADER] = f"{xff}, {client_ip}"
        else:
            forward_headers[FORWARDED_FOR_HEADER] = client_ip
        forward_headers[FORWARDED_PROTO_HEADER] = "https"

        # Body
        body = await request.read()

        if not self._client:
            logger.error("Backend client not initialized")
            return web.Response(status=502, text="Bad Gateway: proxy not ready")

        target_url = f"{BACKEND_BASE}{path_qs}"
        try:
            # Use streaming response to preserve backend streaming and keepalive
            async with self._client.request(method, target_url, headers=forward_headers, data=body) as resp:
                # Build StreamResponse to stream back to client
                response = web.StreamResponse(status=resp.status, reason=resp.reason)
                # copy headers (excluding hop-by-hop)
                for k, v in resp.headers.items():
                    lk = k.lower()
                    if lk in ("transfer-encoding", "connection"):
                        continue
                    response.headers[k] = v

                # Important: avoid aiohttp injecting default content_type
                response.content_type = None

                await response.prepare(request)

                # Stream chunks from backend to client
                async for chunk in resp.content.iter_chunked(8192):
                    if chunk:
                        await response.write(chunk)

                await response.write_eof()
                return response

        except ClientConnectionError as e:
            logger.exception("Backend connection failed: %s", e)
            return web.Response(status=502, text=f"Bad Gateway: backend connection failed: {e}")
        except asyncio.TimeoutError:
            logger.exception("Backend request timed out")
            return web.Response(status=504, text="Gateway Timeout: backend did not respond")
        except Exception:
            logger.exception("Unexpected proxy error")
            return web.Response(status=502, text="Bad Gateway: unexpected proxy error")

# ===========================
# App factory & SSL context
# ===========================
async def init_app() -> web.Application:
    proxy = DualAuthProxy()
    app = web.Application()
    app["proxy"] = proxy

    async def handler(request):
        return await app["proxy"].handle_request(request)

    app.router.add_route("*", "/{path_info:.*}", handler)

    # lifecycle hooks
    async def on_startup(app):
        await app["proxy"].start()

    async def on_cleanup(app):
        await app["proxy"].close()

    app.on_startup.append(on_startup)
    app.on_cleanup.append(on_cleanup)
    return app

def create_ssl_context() -> ssl.SSLContext:
    ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
    # Use modern minimum TLS; do not use deprecated OP_NO_TLS flags
    try:
        ctx.minimum_version = ssl.TLSVersion.TLSv1_2
    except Exception:
        # older Python may not support TLSVersion enum; ignore
        pass

    # load server cert
    ctx.load_cert_chain(SERVER_CERT_FILE, SERVER_KEY_FILE)

    # client cert verification
    try:
        ctx.load_verify_locations(CA_CERT_FILE)
        ctx.verify_mode = CLIENT_CERT_REQUIRED
        logger.info("Loaded CA for client verification; verify_mode=%s", CLIENT_CERT_REQUIRED)
    except Exception:
        logger.warning("Could not load CA file; client cert verification disabled")
        ctx.verify_mode = ssl.CERT_NONE

    return ctx

# ===========================
# Entrypoint
# ===========================
def main():
    app = asyncio.get_event_loop().run_until_complete(init_app())
    ssl_ctx = create_ssl_context()
    logger.info("Starting async SSL proxy on https://%s:%s -> %s", PROXY_HOST, PROXY_PORT, BACKEND_BASE)
    web.run_app(app, host=PROXY_HOST, port=PROXY_PORT, ssl_context=ssl_ctx)

if __name__ == "__main__":
    main()
