
from fastapi import APIRouter, HTTPException, Depends, Request
from pydantic import BaseModel
import os
from typing import Optional

from controller.deps import verify_token, verify_approver_jwt, require_execution_token
from controller.db.db import get_db
from controller.emailer import send_email

router = APIRouter(prefix="/workflows", tags=["workflows"])

class ReexecRequest(BaseModel):
    note: Optional[str] = None
    requester_email: Optional[str] = None

@router.post("/{workflow_id}/reexec/request")
async def request_reexecution(workflow_id: str, payload: ReexecRequest, user: dict = Depends(verify_token)):
    """
    Request approval for (re-)execution of a workflow.
    Creates an approval request and emails the approver(s).
    """
    db = get_db()
    wf = db.get_workflow(workflow_id)
    if not wf:
        raise HTTPException(status_code=404, detail="Workflow not found")

    # create request
    requester = user.get('username') or user.get('token_name') or 'unknown'
    requester_email = payload.requester_email or wf.get('notify_email') or None
    req = db.create_execution_approval_request(workflow_id, requester, requester_email, payload.note or "")

    # Email the approver(s)
    # Prefer workflow.notify_email if present; otherwise fail safe: return request created and log
    approver_target = wf.get('notify_email') or requester_email
    if not approver_target:
        logger.warning("No approver email configured for workflow %s", workflow_id)
        return {"message": "Approval request created", "request": req}

    # Construct approval URL - approvers must be authenticated via JWT in our design
    api_host = os.getenv("API_HOST", "http://localhost:8000")
    approve_url = f"{api_host}/api/workflows/{workflow_id}/reexec/approve?request_id={req['id']}"

    html = f"""
    <p>A request to execute workflow <strong>{workflow_id}</strong> was created by {requester}.</p>
    <p>Note: {payload.note or '(none)'}</p>
    <p>Approver must authenticate via web UI (JWT) and then call the approve endpoint or use the dashboard.</p>
    <p>To approve (requires approver JWT): <code>POST {approve_url}</code></p>
    """

    send_email(approver_target, f"Execution approval required for {workflow_id}", html)
    return {"message": "Approval request created and approver notified", "request": req}


class ApprovePayload(BaseModel):
    request_id: int

@router.post("/{workflow_id}/reexec/approve")
async def approve_reexecution(workflow_id: str, payload: ApprovePayload, approver_jwt: dict = Depends(verify_approver_jwt)):
    """
    Approver approves a re-execution. Approver authenticates with JWT (Authorization: Bearer <jwt>).
    On success: an execution token is created and emailed to the original requester.
    """
    db = get_db()
    req = db.get_execution_approval_request(payload.request_id)
    if not req:
        raise HTTPException(status_code=404, detail="Approval request not found")
    if req['workflow_id'] != workflow_id:
        raise HTTPException(status_code=400, detail="Mismatched workflow")

    if req['status'] != 'pending':
        raise HTTPException(status_code=400, detail="Request not pending")

    approver = approver_jwt.get('sub') or approver_jwt.get('username') or approver_jwt.get('email') or 'approver'
    token_row = db.approve_execution_request(payload.request_id, approver)
    if not token_row:
        raise HTTPException(status_code=500, detail="Failed to approve request")

    # Email token to requester (use stored requester_email in request or workflow.notify_email)
    requester_email = req.get('requester_email') or (db.get_workflow(workflow_id) or {}).get('notify_email')
    if requester_email:
        html = f"""
        <p>Your execution request for workflow <strong>{workflow_id}</strong> has been approved.</p>
        <p>Use the following one-time execution token to run the workflow (valid until {token_row.get('expires_at')}):</p>
        <pre>{token_row.get('token')}</pre>
        <p>Call the execute API with header <code>X-Execution-Token</code> containing the token.</p>
        """
        send_email(requester_email, f"Execution token for {workflow_id}", html)

    return {"message": "Approved and token issued", "token_id": token_row.get('id')}


class ExecutePayload(BaseModel):
    # payload for execution API if any extra params
    pass

@router.post("/{workflow_id}/execute")
async def execute_workflow(workflow_id: str, payload: Optional[ExecutePayload] = None, token_row = Depends(require_execution_token(workflow_id)), user: dict = Depends(verify_token)):
    """
    Execute workflow with a valid X-Execution-Token header.
    Requires token validated by dependency.
    """
    db = get_db()
    wf = db.get_workflow(workflow_id)
    if not wf:
        raise HTTPException(status_code=404, detail="Workflow not found")

    # Create execution record
    executor = user.get('username') or user.get('token_name') or 'unknown'
    exec_id = db.create_execution_record(workflow_id, executor, status="running", log_file=None)

    # call script runner (scripts.py) -- keep behavior same as before
    # Example: delegate to scripts module responsible to run the actual script by workflow['script_id']
    from controller.scripts import run_workflow_script
    try:
        result = run_workflow_script(workflow_id, wf, exec_id)
        db.complete_execution_record(exec_id, status="success", result_json=json.dumps(result) if result else "{}")
        return {"message": "Execution started", "execution_id": exec_id}
    except Exception as e:
        db.complete_execution_record(exec_id, status="failed", result_json=json.dumps({"error": str(e)}))
        raise HTTPException(status_code=500, detail=f"Execution failed: {e}")
